diff --git a/algo/kernels/basic/hifi5/xa_nn_elm_squared_diff_quant16.c b/algo/kernels/basic/hifi5/xa_nn_elm_squared_diff_quant16.c
new file mode 100644
index 0000000..1527b0f
--- /dev/null
+++ b/algo/kernels/basic/hifi5/xa_nn_elm_squared_diff_quant16.c
@@ -0,0 +1,569 @@
+/*******************************************************************************
+* Copyright (c) 2018-2023 Cadence Design Systems, Inc.
+*
+* Permission is hereby granted, free of charge, to any person obtaining
+* a copy of this software and associated documentation files (the
+* "Software"), to use this Software with Cadence processor cores only and
+* not with any other processors and platforms, subject to
+* the following conditions:
+*
+* The above copyright notice and this permission notice shall be included
+* in all copies or substantial portions of the Software.
+*
+* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+
+******************************************************************************/
+#include "xa_nnlib_common.h"
+#include "xa_nn_basic_state.h"
+#include "xa_nnlib_common_macros_hifi5.h"
+
+static void internal_elm_squared_diff_broadcast_2D_sym16sxsym16s_sym16s(WORD16 * __restrict__ p_out,
+                            WORD32  out_left_shift,
+                            WORD32  out_multiplier,
+                            WORD32  out_activation_min,
+                            WORD32  out_activation_max,
+                    const   WORD16 * __restrict__ p_inp1,
+                            WORD32  inp1_left_shift,
+                            WORD32  inp1_multiplier,
+                    const   WORD16 * __restrict__ p_inp2,
+                            WORD32  inp2_left_shift,
+                            WORD32  inp2_multiplier,
+                            WORD32  left_shift,
+                            WORD32  out_lc,
+                            WORD32  in_lc)
+{
+#if TFLITE_SINGLE_ROUNDING
+  WORD32 out_ls, out_rs;
+  out_ls = out_left_shift;
+  out_rs = out_left_shift;
+  (void)out_rs;
+#else
+  WORD32 out_ls, out_rs;
+  out_ls = out_left_shift > 0 ? out_left_shift : 0;
+  out_rs = out_left_shift < 0 ? -out_left_shift : 0;
+#endif
+  int i, j;
+  ae_int16x8 * __restrict__ p_a;
+  ae_int16x8 * __restrict__ p_b;
+  ae_int16x8 *__restrict__ p_c;
+
+  ae_int16x4 a0_3, a4_7, b0_3, b4_7;
+
+  ae_int32x2 shifted_a0_1, shifted_a2_3, shifted_a4_5, shifted_a6_7;
+  ae_int32x2 shifted_b0_1, shifted_b2_3, shifted_b4_5, shifted_b6_7;
+
+  ae_int32x2 raw_diff0_1, raw_diff2_3, raw_diff4_5, raw_diff6_7;
+
+  ae_int16x4 out0, out1;
+
+  int num_simd8_ops;
+  int num_scalar_ops;
+
+  num_simd8_ops = in_lc >> 3;
+  num_scalar_ops = in_lc & 7;
+
+  ae_valignx2 va_a, va_b, va_c;
+
+#pragma loop_count min=1
+  for(i = 0; i < out_lc; i++)
+  {
+    p_a = (ae_int16x8 *)&p_inp1[i * in_lc];
+    p_b = (ae_int16x8 *)p_inp2;
+    p_c = (ae_int16x8 *)&p_out[i * in_lc];
+
+    va_a = AE_LA128_PP(p_a);
+    va_b = AE_LA128_PP(p_b);
+    va_c = AE_ZALIGN128();
+    for(j = 0; j < num_simd8_ops; j++)
+    {
+      AE_LA16X4X2_IP(a0_3, a4_7, va_a, p_a);
+      AE_LA16X4X2_IP(b0_3, b4_7, va_b, p_b);
+
+      // LSH (and promote to 32-bit)
+      AE_CVTA32X4F16S(shifted_a0_1, shifted_a2_3, a0_3, left_shift);
+      AE_CVTA32X4F16S(shifted_a4_5, shifted_a6_7, a4_7, left_shift);
+
+      AE_CVTA32X4F16S(shifted_b0_1, shifted_b2_3, b0_3, left_shift);
+      AE_CVTA32X4F16S(shifted_b4_5, shifted_b6_7, b4_7, left_shift);
+
+      raw_diff0_1 = raw_diff2_3 = raw_diff4_5 = raw_diff6_7 = AE_ZERO32();
+      // Scaled input
+      MPY_BY_QUANT_MACC_ST_ONE_EXP_X2X2_OUT32(raw_diff0_1, raw_diff2_3, shifted_a0_1, shifted_a2_3, inp1_multiplier, inp1_left_shift);
+      MPY_BY_QUANT_MACC_ST_ONE_EXP_X2X2_OUT32(raw_diff4_5, raw_diff6_7, shifted_a4_5, shifted_a6_7, inp1_multiplier, inp1_left_shift);
+      MPY_BY_QUANT_MSUB_ST_ONE_EXP_X2X2_OUT32(raw_diff0_1, raw_diff2_3, shifted_b0_1, shifted_b2_3, inp2_multiplier, inp2_left_shift);
+      MPY_BY_QUANT_MSUB_ST_ONE_EXP_X2X2_OUT32(raw_diff4_5, raw_diff6_7, shifted_b4_5, shifted_b6_7, inp2_multiplier, inp2_left_shift);
+
+      AE_MUL2P32X4S(raw_diff0_1, raw_diff2_3, raw_diff0_1, raw_diff2_3, raw_diff0_1, raw_diff2_3);
+      AE_MUL2P32X4S(raw_diff4_5, raw_diff6_7, raw_diff4_5, raw_diff6_7, raw_diff4_5, raw_diff6_7);
+
+      // Raw Output
+      MPY_BY_QUANT_MULT_SLS_X2X2_OUT16(out0, raw_diff0_1, raw_diff2_3, out_multiplier, out_ls, out_rs);
+      MPY_BY_QUANT_MULT_SLS_X2X2_OUT16(out1, raw_diff4_5, raw_diff6_7, out_multiplier, out_ls, out_rs);
+
+      // Clamp output
+      AE_MINMAX16(out0, AE_MOVDA16(out_activation_min), AE_MOVDA16(out_activation_max));
+      AE_MINMAX16(out1, AE_MOVDA16(out_activation_min), AE_MOVDA16(out_activation_max));
+
+      AE_SA16X4X2_IP(out0, out1, va_c, p_c);
+    }
+    AE_SA128POS_FP(va_c, p_c);
+  }
+
+  if(num_scalar_ops != 0)
+  {
+    ae_int32x2 scaled_b0_1, scaled_b2_3, scaled_b4_5, scaled_b6_7;
+
+    p_b = (ae_int16x8 *)&p_inp2[num_simd8_ops << 3];
+    va_b = AE_LA128_PP(p_b);
+    AE_LAV16X4X2_XP(b0_3, b4_7, va_b, p_b, (num_scalar_ops << 1));
+
+    AE_CVTA32X4F16S(shifted_b0_1, shifted_b2_3, b0_3, left_shift);
+    AE_CVTA32X4F16S(shifted_b4_5, shifted_b6_7, b4_7, left_shift);
+
+    MPY_BY_QUANT_MULT_ST_ONE_EXP_X2X2_OUT32(scaled_b0_1, scaled_b2_3, shifted_b0_1, shifted_b2_3, inp2_multiplier, inp2_left_shift);
+    MPY_BY_QUANT_MULT_ST_ONE_EXP_X2X2_OUT32(scaled_b4_5, scaled_b6_7, shifted_b4_5, shifted_b6_7, inp2_multiplier, inp2_left_shift);
+
+#pragma loop_count min=1
+    for(i = 0; i < out_lc; i++)
+    {
+      p_a = (ae_int16x8 *)&p_inp1[i * in_lc + (num_simd8_ops << 3)];
+      p_c = (ae_int16x8 *)&p_out[i * in_lc + (num_simd8_ops << 3)];
+
+      va_a = AE_LA128_PP(p_a);
+      va_c = AE_ZALIGN128();
+
+      AE_LAV16X4X2_XP(a0_3, a4_7, va_a, p_a, (num_scalar_ops << 1));
+
+      // LSH (and promote to 32-bit)
+      AE_CVTA32X4F16S(shifted_a0_1, shifted_a2_3, a0_3, left_shift);
+      AE_CVTA32X4F16S(shifted_a4_5, shifted_a6_7, a4_7, left_shift);
+
+      raw_diff0_1 = scaled_b0_1;
+      raw_diff2_3 = scaled_b2_3;
+      raw_diff4_5 = scaled_b4_5;
+      raw_diff6_7 = scaled_b6_7;
+
+      // Scaled input
+      MPY_BY_QUANT_MSUB_ST_ONE_EXP_X2X2_OUT32(raw_diff0_1, raw_diff2_3, shifted_a0_1, shifted_a2_3, inp1_multiplier, inp1_left_shift);
+      MPY_BY_QUANT_MSUB_ST_ONE_EXP_X2X2_OUT32(raw_diff4_5, raw_diff6_7, shifted_a4_5, shifted_a6_7, inp1_multiplier, inp1_left_shift);
+
+      AE_MUL2P32X4S(raw_diff0_1, raw_diff2_3, raw_diff0_1, raw_diff2_3, raw_diff0_1, raw_diff2_3);
+      AE_MUL2P32X4S(raw_diff4_5, raw_diff6_7, raw_diff4_5, raw_diff6_7, raw_diff4_5, raw_diff6_7);
+
+      // Raw Output
+      MPY_BY_QUANT_MULT_SLS_X2X2_OUT16(out0, raw_diff0_1, raw_diff2_3, out_multiplier, out_ls, out_rs);
+      MPY_BY_QUANT_MULT_SLS_X2X2_OUT16(out1, raw_diff4_5, raw_diff6_7, out_multiplier, out_ls, out_rs);
+
+      // Clamp output
+      AE_MINMAX16(out0, AE_MOVDA16(out_activation_min), AE_MOVDA16(out_activation_max));
+      AE_MINMAX16(out1, AE_MOVDA16(out_activation_min), AE_MOVDA16(out_activation_max));
+
+      AE_SAV16X4X2_XP(out0, out1, va_c, p_c, (num_scalar_ops << 1));
+      AE_SA128POS_FP(va_c, p_c);
+    }
+  }
+}
+
+static void internal_elm_squared_diff_broadcast_sym16sxsym16s_sym16s(WORD16 * __restrict__ p_out,
+                            WORD32  out_left_shift,
+                            WORD32  out_multiplier,
+                            WORD32  out_activation_min,
+                            WORD32  out_activation_max,
+                    const   WORD16 * __restrict__ p_inp1,
+                            WORD32  inp1_left_shift,
+                            WORD32  inp1_multiplier,
+                    const   WORD16 * __restrict__ p_inp2,
+                            WORD32  inp2_left_shift,
+                            WORD32  inp2_multiplier,
+                            WORD32  left_shift,
+                            WORD32  num_elm)
+{
+#if TFLITE_SINGLE_ROUNDING
+  WORD32 out_ls, out_rs;
+  out_ls = out_left_shift;
+  out_rs = out_left_shift;
+  (void)out_rs;
+#else
+  WORD32 out_ls, out_rs;
+  out_ls = out_left_shift > 0 ? out_left_shift : 0;
+  out_rs = out_left_shift < 0 ? -out_left_shift : 0;
+#endif
+  int i;
+  ae_int16x8 * __restrict__ p_a = (ae_int16x8 *)p_inp1;
+  ae_int16x8 * __restrict__ p_c = (ae_int16x8 *)p_out;
+
+  WORD32 a_ls, a_mult, b_ls, b_mult;
+  a_ls = inp1_left_shift;
+  a_mult = inp1_multiplier;
+  b_ls = inp2_left_shift;
+  b_mult = inp2_multiplier;
+
+  // intermediate results and scratch registers
+  ae_int16x4 a0_3, a4_7, b0;
+
+  ae_int32x2 shifted_a0_1, shifted_a2_3, shifted_a4_5, shifted_a6_7;
+  ae_int32x2 shifted_b0, shifted_b1;
+  ae_int32x2 scaled_b0;
+
+  ae_int32x2 raw_diff0_1, raw_diff2_3, raw_diff4_5, raw_diff6_7;
+
+  ae_int16x4 out0, out1;
+
+  const int num_simd8_ops = num_elm >> 3;
+  const int num_scalar_ops = num_elm & 7;
+
+  ae_valignx2 va_a = AE_LA128_PP(p_a);
+  ae_valignx2 va_c = AE_ZALIGN128();
+
+  b0 = AE_MOVDA16(p_inp2[0]);
+  AE_CVTA32X4F16S(shifted_b0, shifted_b1, b0, left_shift);
+  MPY_BY_QUANT_MULT_ST_ONE_EXP_X2_OUT32(scaled_b0, shifted_b0, b_mult, b_ls);
+
+  ae_int32x2 ALIGN(16) scaled_b[2];
+  scaled_b[0] = scaled_b[1] = scaled_b0;
+
+  ae_int32x4 *p_scaled_b = (ae_int32x4 *)scaled_b;
+  for(i=0; i<num_simd8_ops; i++)
+  {
+    AE_LA16X4X2_IP(a0_3, a4_7, va_a, p_a);
+
+    // LSH (and promote to 32-bit)
+    AE_CVTA32X4F16S(shifted_a0_1, shifted_a2_3, a0_3, left_shift);
+    AE_CVTA32X4F16S(shifted_a4_5, shifted_a6_7, a4_7, left_shift);
+
+    AE_L32X2X2_I(raw_diff0_1, raw_diff2_3, p_scaled_b, 0);
+    AE_L32X2X2_IP(raw_diff4_5, raw_diff6_7, p_scaled_b, 0);
+    // Scaled input
+    MPY_BY_QUANT_MSUB_ST_ONE_EXP_X2X2_OUT32(raw_diff0_1, raw_diff2_3, shifted_a0_1, shifted_a2_3, a_mult, a_ls);
+    MPY_BY_QUANT_MSUB_ST_ONE_EXP_X2X2_OUT32(raw_diff4_5, raw_diff6_7, shifted_a4_5, shifted_a6_7, a_mult, a_ls);
+
+    AE_MUL2P32X4S(raw_diff0_1, raw_diff2_3, raw_diff0_1, raw_diff2_3, raw_diff0_1, raw_diff2_3);
+    AE_MUL2P32X4S(raw_diff4_5, raw_diff6_7, raw_diff4_5, raw_diff6_7, raw_diff4_5, raw_diff6_7);
+
+    MPY_BY_QUANT_MULT_SLS_X2X2_OUT16(out0, raw_diff0_1, raw_diff2_3, out_multiplier, out_ls, out_rs);
+    MPY_BY_QUANT_MULT_SLS_X2X2_OUT16(out1, raw_diff4_5, raw_diff6_7, out_multiplier, out_ls, out_rs);
+
+    // Clamp output
+    AE_MINMAX16(out0, AE_MOVDA16(out_activation_min), AE_MOVDA16(out_activation_max));
+    AE_MINMAX16(out1, AE_MOVDA16(out_activation_min), AE_MOVDA16(out_activation_max));
+
+    AE_SA16X4X2_IP(out0, out1, va_c, p_c);
+  }
+  AE_SA128POS_FP(va_c, p_c);
+
+  if(num_scalar_ops != 0)
+  {
+    va_a = AE_LA128_PP(p_a);
+    va_c = AE_ZALIGN128();
+
+    AE_LAV16X4X2_XP(a0_3, a4_7, va_a, p_a, (num_scalar_ops << 1));
+
+    // LSH (and promote to 32-bit)
+    AE_CVTA32X4F16S(shifted_a0_1, shifted_a2_3, a0_3, left_shift);
+    AE_CVTA32X4F16S(shifted_a4_5, shifted_a6_7, a4_7, left_shift);
+
+    raw_diff0_1 = raw_diff2_3 = raw_diff4_5 = raw_diff6_7 = scaled_b0;
+    // Scaled input
+    MPY_BY_QUANT_MSUB_ST_ONE_EXP_X2X2_OUT32(raw_diff0_1, raw_diff2_3, shifted_a0_1, shifted_a2_3, a_mult, a_ls);
+    MPY_BY_QUANT_MSUB_ST_ONE_EXP_X2X2_OUT32(raw_diff4_5, raw_diff6_7, shifted_a4_5, shifted_a6_7, a_mult, a_ls);
+
+    AE_MUL2P32X4S(raw_diff0_1, raw_diff2_3, raw_diff0_1, raw_diff2_3, raw_diff0_1, raw_diff2_3);
+    AE_MUL2P32X4S(raw_diff4_5, raw_diff6_7, raw_diff4_5, raw_diff6_7, raw_diff4_5, raw_diff6_7);
+
+    MPY_BY_QUANT_MULT_SLS_X2X2_OUT16(out0, raw_diff0_1, raw_diff2_3, out_multiplier, out_ls, out_rs);
+    MPY_BY_QUANT_MULT_SLS_X2X2_OUT16(out1, raw_diff4_5, raw_diff6_7, out_multiplier, out_ls, out_rs);
+
+    // Clamp output
+    AE_MINMAX16(out0, AE_MOVDA16(out_activation_min), AE_MOVDA16(out_activation_max));
+    AE_MINMAX16(out1, AE_MOVDA16(out_activation_min), AE_MOVDA16(out_activation_max));
+
+    AE_SAV16X4X2_XP(out0, out1, va_c, p_c, (num_scalar_ops << 1));
+    AE_SA128POS_FP(va_c, p_c);
+  }
+}
+
+WORD32 xa_nn_elm_squared_diff_broadcast_4D_sym16sxsym16s_sym16s(WORD16 * __restrict__ p_out,
+                      const WORD32 *const p_out_shape,
+                            WORD32  out_left_shift,
+                            WORD32  out_multiplier,
+                            WORD32  out_activation_min,
+                            WORD32  out_activation_max,
+                      const WORD16 * __restrict__ p_inp1,
+                      const WORD32 *const p_inp1_shape,
+                            WORD32  inp1_left_shift,
+                            WORD32  inp1_multiplier,
+                      const WORD16 * __restrict__ p_inp2,
+                      const WORD32 *const p_inp2_shape,
+                            WORD32  inp2_left_shift,
+                            WORD32  inp2_multiplier,
+                            WORD32  left_shift)
+{
+  /* NULL pointer checks */
+  XA_NNLIB_ARG_CHK_PTR(p_out, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_inp1, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_inp2, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_out_shape, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_inp1_shape, -1);
+  XA_NNLIB_ARG_CHK_PTR(p_inp2_shape, -1);
+  /* Pointer alignment checks */
+  XA_NNLIB_ARG_CHK_ALIGN(p_out, sizeof(WORD16), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_inp1, sizeof(WORD16), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_inp2, sizeof(WORD16), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_out_shape, sizeof(WORD32), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_inp1_shape, sizeof(WORD32), -1);
+  XA_NNLIB_ARG_CHK_ALIGN(p_inp2_shape, sizeof(WORD32), -1);
+  /* Basic Parameter checks */
+  XA_NNLIB_ARG_CHK_COND((( out_left_shift < -31) || ( out_left_shift > 31)), -1);
+  XA_NNLIB_ARG_CHK_COND(((inp1_left_shift < -31) || (inp1_left_shift > 0)), -1);
+  XA_NNLIB_ARG_CHK_COND(((inp2_left_shift < -31) || (inp2_left_shift > 0)), -1);
+  XA_NNLIB_ARG_CHK_COND((left_shift != 0), -1);
+  XA_NNLIB_ARG_CHK_COND(((out_activation_min < -32768) || (out_activation_min > 32767)), -1);
+  XA_NNLIB_ARG_CHK_COND(((out_activation_max < out_activation_min) || (out_activation_max > 32767)), -1);
+
+  /* Check shapes */
+  int i;
+  for(i = 0; i < 4; i++)
+  {
+    if((p_inp1_shape[i] != p_inp2_shape[i] && p_inp1_shape[i] != 1 && p_inp2_shape[i] != 1) ||
+       (p_out_shape[i] != (p_inp1_shape[i] > p_inp2_shape[i] ? p_inp1_shape[i] : p_inp2_shape[i])))
+    {
+      return -1;
+    }
+  }
+
+  WORD32 inp1_strides[4], inp2_strides[4];
+  inp1_strides[3] = 1;
+  inp2_strides[3] = 1;
+  for(i = 2; i >= 0; i--)
+  {
+    // inp1_strides[i] = inp1_strides[i + 1] * p_inp1_shape[i + 1];
+    // inp2_strides[i] = inp2_strides[i + 1] * p_inp2_shape[i + 1];
+    ae_int32x2 d_str, d_shape;
+    d_str = AE_MOVDA32X2(inp1_strides[i + 1], inp2_strides[i + 1]);
+    d_shape = AE_MOVDA32X2(p_inp1_shape[i + 1], p_inp2_shape[i + 1]);
+    d_str = AE_MULP32X2(d_str, d_shape);
+    inp1_strides[i] = AE_MOVAD32_H(d_str);
+    inp2_strides[i] = AE_MOVAD32_L(d_str);
+  }
+
+  int need_broadcast = 0;
+  int inp1_const = 1, inp2_const = 1;
+  for(i = 0; i < 4; i++)
+  {
+    if(p_inp1_shape[i] != p_inp2_shape[i])
+    {
+      if(p_inp1_shape[i] == 1)
+        inp1_strides[i] = 0;
+      else
+        inp2_strides[i] = 0;
+
+      need_broadcast = 1;
+    }
+    if(p_inp1_shape[i] != 1)
+      inp1_const &= 0;
+    if(p_inp2_shape[i] != 1)
+      inp2_const &= 0;
+  }
+  int itr0, itr1, itr2;
+
+  WORD16 *p_out_tmp = p_out;
+  const WORD16 *__restrict__ p_inp1_tmp = p_inp1;
+  const WORD16 *__restrict__ p_inp2_tmp = p_inp2;
+  if(need_broadcast == 0)
+  {
+    internal_elm_squared_diff_broadcast_2D_sym16sxsym16s_sym16s(
+                p_out,
+                out_left_shift,
+                out_multiplier,
+                out_activation_min,
+                out_activation_max,
+                p_inp1,
+                inp1_left_shift,
+                inp1_multiplier,
+                p_inp2,
+                inp2_left_shift,
+                inp2_multiplier,
+                left_shift,
+                1,
+                p_out_shape[0] * inp1_strides[0]);
+  }
+  else if(inp1_strides[3] == inp2_strides[3])
+  {
+    WORD32 in_lc, out_lc;
+    WORD32 inp1_ls, inp1_mult;
+    WORD32 inp2_ls, inp2_mult;
+
+    inp1_ls = inp1_left_shift;
+    inp1_mult = inp1_multiplier;
+    inp2_ls = inp2_left_shift;
+    inp2_mult = inp2_multiplier;
+
+    in_lc = p_out_shape[2] * p_out_shape[3];
+    out_lc = 1;
+
+    /* Reversing the inputs is okay because difference is squared */
+    if(inp1_strides[2] == 0)
+    {
+      inp2_ls = inp1_left_shift;
+      inp2_mult = inp1_multiplier;
+      inp1_ls = inp2_left_shift;
+      inp1_mult = inp2_multiplier;
+      const WORD16 *tmp;
+      tmp = p_inp1_tmp;   p_inp1_tmp = p_inp2_tmp;    p_inp2_tmp = tmp;
+
+      int tmp_strides[2];
+      tmp_strides[0] = inp1_strides[0];
+      tmp_strides[1] = inp1_strides[1];
+
+      inp1_strides[0] = inp2_strides[0];
+      inp1_strides[1] = inp2_strides[1];
+
+      inp2_strides[0] = tmp_strides[0];
+      inp2_strides[1] = tmp_strides[1];
+      in_lc = p_out_shape[3];
+      out_lc = p_out_shape[2];
+    }
+    else if(inp2_strides[2] == 0)
+    {
+      in_lc = p_out_shape[3];
+      out_lc = p_out_shape[2];
+    }
+
+    for(itr0 = 0; itr0 < p_out_shape[0]; itr0++)
+    {
+      const WORD16 *__restrict__ p_inp1_tmp0 = p_inp1_tmp;
+      const WORD16 *__restrict__ p_inp2_tmp0 = p_inp2_tmp;
+      for(itr1 = 0; itr1 < p_out_shape[1]; itr1++)
+      {
+        internal_elm_squared_diff_broadcast_2D_sym16sxsym16s_sym16s(
+            p_out_tmp,
+            out_left_shift,
+            out_multiplier,
+            out_activation_min,
+            out_activation_max,
+            p_inp1_tmp0,
+            inp1_ls,
+            inp1_mult,
+            p_inp2_tmp0,
+            inp2_ls,
+            inp2_mult,
+            left_shift,
+            out_lc,
+            in_lc);
+        p_out_tmp += in_lc * out_lc;
+        p_inp1_tmp0 += inp1_strides[1];
+        p_inp2_tmp0 += inp2_strides[1];
+      }
+      p_inp1_tmp += inp1_strides[0];
+      p_inp2_tmp += inp2_strides[0];
+    }
+  }
+  else if(inp1_const == 1 || inp2_const == 1)
+  {
+    WORD32 inp1_ls, inp1_mult;
+    WORD32 inp2_ls, inp2_mult;
+    inp1_ls = inp1_left_shift;
+    inp1_mult = inp1_multiplier;
+    inp2_ls = inp2_left_shift;
+    inp2_mult = inp2_multiplier;
+    /* Reversing the inputs is okay because difference is squared */
+    if(inp1_strides[3] == 0)
+    {
+      inp2_ls = inp1_left_shift;
+      inp2_mult = inp1_multiplier;
+      inp1_ls = inp2_left_shift;
+      inp1_mult = inp2_multiplier;
+      const WORD16 *tmp;
+      tmp = p_inp1_tmp;   p_inp1_tmp = p_inp2_tmp;    p_inp2_tmp = tmp;
+    }
+    internal_elm_squared_diff_broadcast_sym16sxsym16s_sym16s(
+        p_out_tmp,
+        out_left_shift,
+        out_multiplier,
+        out_activation_min,
+        out_activation_max,
+        p_inp1_tmp,
+        inp1_ls,
+        inp1_mult,
+        p_inp2_tmp,
+        inp2_ls,
+        inp2_mult,
+        left_shift,
+        p_out_shape[0] * p_out_shape[1] * p_out_shape[2] * p_out_shape[3]);
+  }
+  else
+  {
+    WORD32 inp1_ls, inp1_mult;
+    WORD32 inp2_ls, inp2_mult;
+    inp1_ls = inp1_left_shift;
+    inp1_mult = inp1_multiplier;
+    inp2_ls = inp2_left_shift;
+    inp2_mult = inp2_multiplier;
+    /* Reversing the inputs is okay because difference is squared */
+    if(inp1_strides[3] == 0)
+    {
+      inp2_ls = inp1_left_shift;
+      inp2_mult = inp1_multiplier;
+      inp1_ls = inp2_left_shift;
+      inp1_mult = inp2_multiplier;
+      const WORD16 *tmp;
+      tmp = p_inp1_tmp;   p_inp1_tmp = p_inp2_tmp;    p_inp2_tmp = tmp;
+
+      int tmp_strides[3];
+      tmp_strides[0] = inp1_strides[0];
+      tmp_strides[1] = inp1_strides[1];
+      tmp_strides[2] = inp1_strides[2];
+
+      inp1_strides[0] = inp2_strides[0];
+      inp1_strides[1] = inp2_strides[1];
+      inp1_strides[2] = inp2_strides[2];
+
+      inp2_strides[0] = tmp_strides[0];
+      inp2_strides[1] = tmp_strides[1];
+      inp2_strides[2] = tmp_strides[2];
+    }
+    for(itr0 = 0; itr0 < p_out_shape[0]; itr0++)
+    {
+      const WORD16 *__restrict__ p_inp1_tmp0 = p_inp1_tmp;
+      const WORD16 *__restrict__ p_inp2_tmp0 = p_inp2_tmp;
+      for(itr1 = 0; itr1 < p_out_shape[1]; itr1++)
+      {
+        const WORD16 *__restrict__ p_inp1_tmp1 = p_inp1_tmp0;
+        const WORD16 *__restrict__ p_inp2_tmp1 = p_inp2_tmp0;
+        for(itr2 = 0; itr2 < p_out_shape[2]; itr2++)
+        {
+          {
+            internal_elm_squared_diff_broadcast_sym16sxsym16s_sym16s(
+                p_out_tmp,
+                out_left_shift,
+                out_multiplier,
+                out_activation_min,
+                out_activation_max,
+                p_inp1_tmp1,
+                inp1_ls,
+                inp1_mult,
+                p_inp2_tmp1,
+                inp2_ls,
+                inp2_mult,
+                left_shift,
+                p_out_shape[3]);
+          }
+          p_out_tmp += p_out_shape[3];
+          p_inp1_tmp1 += inp1_strides[2];
+          p_inp2_tmp1 += inp2_strides[2];
+        }
+        p_inp1_tmp0 += inp1_strides[1];
+        p_inp2_tmp0 += inp2_strides[1];
+      }
+      p_inp1_tmp += inp1_strides[0];
+      p_inp2_tmp += inp2_strides[0];
+    }
+  }
+  return 0;
+}
diff --git a/algo/kernels/basic/hifi5/xa_nn_lstm_utils.c b/algo/kernels/basic/hifi5/xa_nn_lstm_utils.c
index 61bfe35..024a80a 100644
--- a/algo/kernels/basic/hifi5/xa_nn_lstm_utils.c
+++ b/algo/kernels/basic/hifi5/xa_nn_lstm_utils.c
@@ -110,8 +110,8 @@ WORD32 xa_nn_lstm_cell_state_update_16(WORD16* p_cell_state,
   XA_NNLIB_ARG_CHK_ALIGN(p_cell_gate, sizeof(WORD16), -1);
   XA_NNLIB_ARG_CHK_ALIGN(p_input_gate, sizeof(WORD16), -1);
   /* Basic Parameter checks */
-  XA_NNLIB_ARG_CHK_COND((cell_to_forget_shift < -31 || cell_to_forget_shift > -15), -1);
-  XA_NNLIB_ARG_CHK_COND((cell_to_input_shift < -31 || cell_to_input_shift > -15), -1);
+  XA_NNLIB_ARG_CHK_COND((cell_to_forget_shift < -31 || cell_to_forget_shift > -1), -1);
+  XA_NNLIB_ARG_CHK_COND((cell_to_input_shift < -31 || cell_to_input_shift > -1), -1);
   XA_NNLIB_ARG_CHK_COND((num_elms < 0), -1);

   WORD32 ctof_right_shift, ctoi_right_shift;
diff --git a/algo/kernels/cnn/hifi5/xa_nn_conv2d_depthwise_sym8sxasym8s.c b/algo/kernels/cnn/hifi5/xa_nn_conv2d_depthwise_sym8sxasym8s.c
index f9b9c04..386071e 100644
--- a/algo/kernels/cnn/hifi5/xa_nn_conv2d_depthwise_sym8sxasym8s.c
+++ b/algo/kernels/cnn/hifi5/xa_nn_conv2d_depthwise_sym8sxasym8s.c
@@ -834,7 +834,7 @@ static inline void conv2d_nhwc_per_chan_sym8sxasym8s
 #else /*RI6 core*/

 /* 2D Convolution implementation */
-static inline void conv2d_nhwc_per_chan_sym8sxasym8s
+static inline void __attribute__((always_inline)) conv2d_nhwc_per_chan_sym8sxasym8s
   (pWORD8 __restrict__ p_out
   ,const WORD8 *__restrict__ p_ker
   ,const WORD8 *__restrict__ p_inp
diff --git a/algo/kernels/cnn/hifi5/xa_nn_transpose_conv_f32.c b/algo/kernels/cnn/hifi5/xa_nn_transpose_conv_f32.c
index 8af9687..a49cfc2 100644
--- a/algo/kernels/cnn/hifi5/xa_nn_transpose_conv_f32.c
+++ b/algo/kernels/cnn/hifi5/xa_nn_transpose_conv_f32.c
@@ -25,6 +25,20 @@
 #include "xa_nn_transpose_conv_state.h"
 #include <string.h>

+#if !HAVE_VFPU
+DISCARD_FUN_FOR_NONVOID_RETURN(WORD32, xa_nn_transpose_conv_f32, (FLOAT32* output_data,
+            const FLOAT32* input_data,
+            const FLOAT32* filter_data,
+            const FLOAT32* bias_data,
+            int stride_width, int stride_height,
+            int pad_width, int pad_height,
+            int input_depth, int output_depth,
+            int input_height, int input_width,
+            int filter_height, int filter_width,
+            int output_height, int output_width,
+            int num_elements,
+            FLOAT32* scratch_buffer))
+#else
 static inline void tconv2d_f32(FLOAT32* output_data,
     const FLOAT32* input_data,
     const FLOAT32* filter_data,
@@ -601,20 +615,6 @@ static inline void transpose_conv2d_std_f32(FLOAT32* output_data,
   }
 }

-#if !HAVE_VFPU
-DISCARD_FUN_FOR_NONVOID_RETURN(WORD32, xa_nn_transpose_conv_f32, (FLOAT32* output_data,
-            const FLOAT32* input_data,
-            const FLOAT32* filter_data,
-            const FLOAT32* bias_data,
-            int stride_width, int stride_height,
-            int pad_width, int pad_height,
-            int input_depth, int output_depth,
-            int input_height, int input_width,
-            int filter_height, int filter_width,
-            int output_height, int output_width,
-            int num_elements,
-            FLOAT32* scratch_buffer))
-#else
 int xa_nn_transpose_conv_f32(FLOAT32* output_data,
     const FLOAT32* input_data,
     const FLOAT32* filter_data,
diff --git a/algo/kernels/matXvec/hifi5/xa_nn_matXvec_sym8sxasym8s.c b/algo/kernels/matXvec/hifi5/xa_nn_matXvec_sym8sxasym8s.c
index 86d0463..284eaab 100644
--- a/algo/kernels/matXvec/hifi5/xa_nn_matXvec_sym8sxasym8s.c
+++ b/algo/kernels/matXvec/hifi5/xa_nn_matXvec_sym8sxasym8s.c
@@ -1178,19 +1178,102 @@ WORD32 xa_nn_matXvec_sym8sxasym8s_asym8s(
 }

 #ifdef AE_MULAZB8Q8X8
-#define MATXVEC_ALIGNED_VEC_OUT_STRIDE_sym8sxasym8s_16(cols, ptr_vec, ptr_bias, vec_zb, out_stride) \
+#define MATXVEC_ALIGNED_VEC_OUT_STRIDE_sym8sxasym8s_16(cols, ptr_vec, vec_zb, out_stride) \
   ae_int64 biasvc1 = AE_MOVINT64_FROMINT32X2(AE_MOVDA32X2(-vec_zb, 0)); \
   AE_MOVZBVCDR(biasvc1); \
-  ae_valignx2 align_bias; \
-  if(bias_flag) \
-    align_bias = AE_LA128_PP(p_bias); \
+  ae_int16 *pae_out = (ae_int16 *)p_out; \
+  for(m_itr = 0; m_itr < (rows - (4-1)); m_itr += 4) \
+  { \
+    ae_int32x2 d_acc0_0; \
+    ae_int32x2 d_acc1_0; \
+    ae_int8x8 _ae8x8_mat1_00, _ae8x8_mat1_01; \
+    ae_int8x16 *_ae8x16_p_mat1_0 = (ae_int8x16 *) &p_mat1[(m_itr+0)*row_stride1]; \
+    ae_valignx2 _align_ae8x16_p_mat1_0 = AE_LA128_PP(_ae8x16_p_mat1_0); \
+    ae_int8x8 _ae8x8_mat1_10, _ae8x8_mat1_11; \
+    ae_int8x16 *_ae8x16_p_mat1_1 = (ae_int8x16 *)((char *)_ae8x16_p_mat1_0 + row_stride1); \
+    ae_valignx2 _align_ae8x16_p_mat1_1 = AE_LA128_PP(_ae8x16_p_mat1_1); \
+    ae_int8x8 _ae8x8_mat1_20, _ae8x8_mat1_21; \
+    ae_int8x16 *_ae8x16_p_mat1_2 = (ae_int8x16 *)((char *)_ae8x16_p_mat1_1 + row_stride1); \
+    ae_valignx2 _align_ae8x16_p_mat1_2 = AE_LA128_PP(_ae8x16_p_mat1_2); \
+    ae_int8x8 _ae8x8_mat1_30, _ae8x8_mat1_31; \
+    ae_int8x16 *_ae8x16_p_mat1_3 = (ae_int8x16 *)((char *)_ae8x16_p_mat1_2 + row_stride1); \
+    ae_valignx2 _align_ae8x16_p_mat1_3 = AE_LA128_PP(_ae8x16_p_mat1_3); \
+    p_local_vec = (ae_int8x16 *)ptr_vec; \
+    int cols_count=cols; \
+    { \
+      AE_LA8X8X2_IP(_ae8x8_mat1_00, _ae8x8_mat1_01, _align_ae8x16_p_mat1_0, _ae8x16_p_mat1_0); \
+      AE_LA8X8X2_IP(_ae8x8_mat1_10, _ae8x8_mat1_11, _align_ae8x16_p_mat1_1, _ae8x16_p_mat1_1); \
+      AE_LA8X8X2_IP(_ae8x8_mat1_20, _ae8x8_mat1_21, _align_ae8x16_p_mat1_2, _ae8x16_p_mat1_2); \
+      AE_LA8X8X2_IP(_ae8x8_mat1_30, _ae8x8_mat1_31, _align_ae8x16_p_mat1_3, _ae8x16_p_mat1_3); \
+      AE_L8X8X2_IP(_ae8x8_vec1_00, _ae8x8_vec1_01, p_local_vec, 16); \
+      AE_MULZB8Q8X8(d_acc0_0, d_acc1_0, _ae8x8_mat1_00, _ae8x8_mat1_10, _ae8x8_mat1_20, _ae8x8_mat1_30, _ae8x8_vec1_00); \
+      AE_MULAZB8Q8X8(d_acc0_0, d_acc1_0, _ae8x8_mat1_01, _ae8x8_mat1_11, _ae8x8_mat1_21, _ae8x8_mat1_31, _ae8x8_vec1_01); \
+    } \
+    for(c_itr = 0; c_itr < (cols_count>>4) - 1; c_itr++) \
+    { \
+      AE_LA8X8X2_IP(_ae8x8_mat1_00, _ae8x8_mat1_01, _align_ae8x16_p_mat1_0, _ae8x16_p_mat1_0); \
+      AE_LA8X8X2_IP(_ae8x8_mat1_10, _ae8x8_mat1_11, _align_ae8x16_p_mat1_1, _ae8x16_p_mat1_1); \
+      AE_LA8X8X2_IP(_ae8x8_mat1_20, _ae8x8_mat1_21, _align_ae8x16_p_mat1_2, _ae8x16_p_mat1_2); \
+      AE_LA8X8X2_IP(_ae8x8_mat1_30, _ae8x8_mat1_31, _align_ae8x16_p_mat1_3, _ae8x16_p_mat1_3); \
+      AE_L8X8X2_IP(_ae8x8_vec1_00, _ae8x8_vec1_01, p_local_vec, 16); \
+      AE_MULAZB8Q8X8(d_acc0_0, d_acc1_0, _ae8x8_mat1_00, _ae8x8_mat1_10, _ae8x8_mat1_20, _ae8x8_mat1_30, _ae8x8_vec1_00); \
+      AE_MULAZB8Q8X8(d_acc0_0, d_acc1_0, _ae8x8_mat1_01, _ae8x8_mat1_11, _ae8x8_mat1_21, _ae8x8_mat1_31, _ae8x8_vec1_01); \
+    } \
+    ae_int16x4 _ae_int16x4_out; \
+    MPY_BY_QUANT_MULT_X2X2_OUT16(_ae_int16x4_out, d_acc0_0, d_acc1_0, out_multiplier, left_shift, right_shift); \
+    *pae_out = AE_SEL16_6543(_ae_int16x4_out, _ae_int16x4_out); \
+    pae_out += out_stride; \
+    *pae_out = AE_SEL16_5432(_ae_int16x4_out, _ae_int16x4_out); \
+    pae_out += out_stride; \
+    *pae_out = AE_SEL16_4321(_ae_int16x4_out, _ae_int16x4_out); \
+    pae_out += out_stride; \
+    *pae_out = (_ae_int16x4_out); \
+    pae_out += out_stride; \
+  } \
+_Pragma("no_unroll") \
+_Pragma("loop_count max=3") \
+  for(m_itr = (rows&(~3)); m_itr < rows; m_itr++) \
+  { \
+    ae_int32x2 d_acc0_0; \
+    ae_int32x2 d_acc1_0; \
+    ae_int8x8 _ae8x8_mat1_00, _ae8x8_mat1_01; \
+    ae_int8x16 *_ae8x16_p_mat1_0 = (ae_int8x16 *) &p_mat1[(m_itr+0)*row_stride1]; \
+    ae_valignx2 _align_ae8x16_p_mat1_0 = AE_LA128_PP(_ae8x16_p_mat1_0); \
+    p_local_vec = (ae_int8x16 *)ptr_vec; \
+    int cols_count=cols; \
+    { \
+      AE_LA8X8X2_IP(_ae8x8_mat1_00, _ae8x8_mat1_01, _align_ae8x16_p_mat1_0, _ae8x16_p_mat1_0); \
+      AE_L8X8X2_IP(_ae8x8_vec1_00, _ae8x8_vec1_01, p_local_vec, 16); \
+      AE_MULZB8Q8X8(d_acc0_0, d_acc1_0, _ae8x8_mat1_00, _ae8x8_mat1_00, _ae8x8_mat1_00, _ae8x8_mat1_00, _ae8x8_vec1_00); \
+      AE_MULAZB8Q8X8(d_acc0_0, d_acc1_0, _ae8x8_mat1_01, _ae8x8_mat1_01, _ae8x8_mat1_01, _ae8x8_mat1_01, _ae8x8_vec1_01); \
+    } \
+    for(c_itr = 0; c_itr < (cols_count>>4) - 1; c_itr++) \
+    { \
+      AE_LA8X8X2_IP(_ae8x8_mat1_00, _ae8x8_mat1_01, _align_ae8x16_p_mat1_0, _ae8x16_p_mat1_0); \
+      AE_L8X8X2_IP(_ae8x8_vec1_00, _ae8x8_vec1_01, p_local_vec, 16); \
+      AE_MULAZB8Q8X8(d_acc0_0, d_acc1_0, _ae8x8_mat1_00, _ae8x8_mat1_00, _ae8x8_mat1_00, _ae8x8_mat1_00, _ae8x8_vec1_00); \
+      AE_MULAZB8Q8X8(d_acc0_0, d_acc1_0, _ae8x8_mat1_01, _ae8x8_mat1_01, _ae8x8_mat1_01, _ae8x8_mat1_01, _ae8x8_vec1_01); \
+    } \
+    MPY_BY_QUANT_MULT_X2_OUT32(d_acc0_0, d_acc0_0, out_multiplier, left_shift, right_shift); \
+    ae_int16x4 _ae_int16x4_out; \
+    _ae_int16x4_out = AE_SAT16X4(d_acc0_0, d_acc0_0); \
+    *pae_out = _ae_int16x4_out; \
+    pae_out += out_stride; \
+  }
+
+#define MATXVEC_ALIGNED_VEC_OUT_STRIDE_bias_sym8sxasym8s_16(cols, ptr_vec, ptr_bias, vec_zb, out_stride) \
+  ae_int64 biasvc1 = AE_MOVINT64_FROMINT32X2(AE_MOVDA32X2(-vec_zb, 0)); \
+  AE_MOVZBVCDR(biasvc1); \
+  ae_int16 *pae_out = (ae_int16 *)p_out; \
   for(m_itr = 0; m_itr < (rows - (4-1)); m_itr += 4) \
   { \
     ae_int32x2 d_acc0_0 = AE_ZERO32(); \
     ae_int32x2 d_acc1_0 = AE_ZERO32(); \
-    if(bias_flag) \
     { \
-      AE_LA32X2X2_IP(d_acc0_0, d_acc1_0, align_bias, (ae_int32x4 *)p_bias); \
+      d_acc0_0 = *(ae_int32 *)p_bias++; \
+      d_acc0_0 = AE_SEL32_LL(d_acc0_0, *(ae_int32 *)p_bias++); \
+      d_acc1_0 = *(ae_int32 *)p_bias++; \
+      d_acc1_0 = AE_SEL32_LL(d_acc1_0, *(ae_int32 *)p_bias++); \
     } \
     ae_int8x8 _ae8x8_mat1_00, _ae8x8_mat1_01; \
     ae_int8x16 *_ae8x16_p_mat1_0 = (ae_int8x16 *) &p_mat1[(m_itr+0)*row_stride1]; \
@@ -1216,13 +1299,16 @@ WORD32 xa_nn_matXvec_sym8sxasym8s_asym8s(
       AE_MULAZB8Q8X8(d_acc0_0, d_acc1_0, _ae8x8_mat1_00, _ae8x8_mat1_10, _ae8x8_mat1_20, _ae8x8_mat1_30, _ae8x8_vec1_00); \
       AE_MULAZB8Q8X8(d_acc0_0, d_acc1_0, _ae8x8_mat1_01, _ae8x8_mat1_11, _ae8x8_mat1_21, _ae8x8_mat1_31, _ae8x8_vec1_01); \
     } \
-    MPY_BY_QUANT_MULT_X2X2_OUT32(d_acc0_0, d_acc1_0, d_acc0_0, d_acc1_0, out_multiplier, left_shift, right_shift); \
     ae_int16x4 _ae_int16x4_out; \
-    _ae_int16x4_out = AE_SAT16X4(d_acc0_0, d_acc1_0); \
-    *(ae_int16 *)&p_out[(m_itr)*out_stride] = AE_SEL16_6543(_ae_int16x4_out, _ae_int16x4_out); \
-    *(ae_int16 *)&p_out[(m_itr+1)*out_stride] = AE_SEL16_5432(_ae_int16x4_out, _ae_int16x4_out); \
-    *(ae_int16 *)&p_out[(m_itr+2)*out_stride] = AE_SEL16_4321(_ae_int16x4_out, _ae_int16x4_out); \
-    *(ae_int16 *)&p_out[(m_itr+3)*out_stride] = (_ae_int16x4_out); \
+    MPY_BY_QUANT_MULT_X2X2_OUT16(_ae_int16x4_out, d_acc0_0, d_acc1_0, out_multiplier, left_shift, right_shift); \
+    *pae_out = AE_SEL16_6543(_ae_int16x4_out, _ae_int16x4_out); \
+    pae_out += out_stride; \
+    *pae_out = AE_SEL16_5432(_ae_int16x4_out, _ae_int16x4_out); \
+    pae_out += out_stride; \
+    *pae_out = AE_SEL16_4321(_ae_int16x4_out, _ae_int16x4_out); \
+    pae_out += out_stride; \
+    *pae_out = (_ae_int16x4_out); \
+    pae_out += out_stride; \
   } \
 _Pragma("no_unroll") \
 _Pragma("loop_count max=3") \
@@ -1230,7 +1316,6 @@ _Pragma("loop_count max=3") \
   { \
     ae_int32x2 d_acc0_0 = AE_ZERO32(); \
     ae_int32x2 d_acc1_0 = AE_ZERO32(); \
-    if(bias_flag) \
     { \
       AE_L32_IP(d_acc0_0, (ae_int32 *)p_bias, 4); \
     } \
@@ -1249,9 +1334,11 @@ _Pragma("loop_count max=3") \
     MPY_BY_QUANT_MULT_X2_OUT32(d_acc0_0, d_acc0_0, out_multiplier, left_shift, right_shift); \
     ae_int16x4 _ae_int16x4_out; \
     _ae_int16x4_out = AE_SAT16X4(d_acc0_0, d_acc0_0); \
-    *(ae_int16 *)&p_out[m_itr*out_stride] = _ae_int16x4_out; \
+    *pae_out = (_ae_int16x4_out); \
+    pae_out += out_stride; \
   }

+
 #endif /* #ifdef AE_MULAZB8Q8X8 */

 WORD32 xa_nn_matXvec_out_stride_sym8sxasym8s_16(
@@ -1342,7 +1429,14 @@ WORD32 xa_nn_matXvec_out_stride_sym8sxasym8s_16(
     AE_SAV8X8X2_XP(d_vec_zb, d_vec_zb, align_p_local_vec, p_local_vec, 48 - cols1);
     AE_SA128POS_FP(align_p_local_vec, p_local_vec);

-    MATXVEC_ALIGNED_VEC_OUT_STRIDE_sym8sxasym8s_16(48, local_vec, p_bias, vec1_zero_bias, out_stride);
+    if(bias_flag)
+    {
+      MATXVEC_ALIGNED_VEC_OUT_STRIDE_bias_sym8sxasym8s_16(48, local_vec, p_bias, vec1_zero_bias, out_stride);
+    }
+    else
+    {
+      MATXVEC_ALIGNED_VEC_OUT_STRIDE_sym8sxasym8s_16(48, local_vec, vec1_zero_bias, out_stride);
+    }
   }
   else if(cols1 > 48 && cols1 <= 64)
   {
@@ -1373,7 +1467,14 @@ WORD32 xa_nn_matXvec_out_stride_sym8sxasym8s_16(
     AE_SAV8X8X2_XP(d_vec_zb, d_vec_zb, align_p_local_vec, p_local_vec, 64 - cols1);
     AE_SA128POS_FP(align_p_local_vec, p_local_vec);

-    MATXVEC_ALIGNED_VEC_OUT_STRIDE_sym8sxasym8s_16(64, local_vec, p_bias, vec1_zero_bias, out_stride);
+    if(bias_flag)
+    {
+      MATXVEC_ALIGNED_VEC_OUT_STRIDE_bias_sym8sxasym8s_16(64, local_vec, p_bias, vec1_zero_bias, out_stride);
+    }
+    else
+    {
+      MATXVEC_ALIGNED_VEC_OUT_STRIDE_sym8sxasym8s_16(64, local_vec, vec1_zero_bias, out_stride);
+    }
   }
   else if(cols1 > 64 && cols1 <= 80)
   {
@@ -1407,7 +1508,14 @@ WORD32 xa_nn_matXvec_out_stride_sym8sxasym8s_16(
     AE_SAV8X8X2_XP(d_vec_zb, d_vec_zb, align_p_local_vec, p_local_vec, 80 - cols1);
     AE_SA128POS_FP(align_p_local_vec, p_local_vec);

-    MATXVEC_ALIGNED_VEC_OUT_STRIDE_sym8sxasym8s_16(80, local_vec, p_bias, vec1_zero_bias, out_stride);
+    if(bias_flag)
+    {
+      MATXVEC_ALIGNED_VEC_OUT_STRIDE_bias_sym8sxasym8s_16(80, local_vec, p_bias, vec1_zero_bias, out_stride);
+    }
+    else
+    {
+      MATXVEC_ALIGNED_VEC_OUT_STRIDE_sym8sxasym8s_16(80, local_vec, vec1_zero_bias, out_stride);
+    }
   }
   else
 #endif /* #ifdef AE_MULAZB8Q8X8 */
diff --git a/algo/kernels/matXvec/hifi5/xa_nn_matmul_f32.c b/algo/kernels/matXvec/hifi5/xa_nn_matmul_f32.c
index 52bf60e..2d1b3eb 100644
--- a/algo/kernels/matXvec/hifi5/xa_nn_matmul_f32.c
+++ b/algo/kernels/matXvec/hifi5/xa_nn_matmul_f32.c
@@ -23,6 +23,21 @@
 #include "xa_nnlib_common.h"
 #include "xa_nnlib_common_macros_hifi5.h"

+#if !HAVE_VFPU
+DISCARD_FUN_FOR_NONVOID_RETURN(WORD32,xa_nn_matmul_f32xf32_f32,(
+    FLOAT32 * __restrict__ p_out,
+    const FLOAT32 * __restrict__ p_mat1,
+    const FLOAT32 * __restrict__ p_vec1,
+    const FLOAT32 * __restrict__ p_bias,
+    WORD32 rows,
+    WORD32 cols1,
+    WORD32 row_stride1,
+    WORD32 vec_count,
+    WORD32 vec_offset,
+    WORD32 out_offset,
+    WORD32 out_stride))
+
+#else
 /* Using the 4 row 1 vec function defined in xa_nn_matXvec_f32.c for xa_nn_matXvec_f32() kernel */
 extern void _xa_nn_dot_product_4_rows_1_vecs_offset_aligned
     (xtfloatx2* out_0_0
@@ -744,21 +759,6 @@ static inline void _xa_nn_dot_product_1_row_4_vecs_unaligned
   *out_1_0 = z1;
 }

-#if !HAVE_VFPU
-DISCARD_FUN_FOR_NONVOID_RETURN(WORD32,xa_nn_matmul_f32xf32_f32,(
-    FLOAT32 * __restrict__ p_out,        
-    const FLOAT32 * __restrict__ p_mat1, 
-    const FLOAT32 * __restrict__ p_vec1, 
-    const FLOAT32 * __restrict__ p_bias, 
-    WORD32 rows,
-    WORD32 cols1,
-    WORD32 row_stride1,                   
-    WORD32 vec_count,                     
-    WORD32 vec_offset,
-    WORD32 out_offset,
-    WORD32 out_stride))                      
-
-#else
 WORD32 xa_nn_matmul_f32xf32_f32(
     FLOAT32 * __restrict__ p_out,          
     const FLOAT32 * __restrict__ p_mat1,   
diff --git a/include/nnlib/xa_nnlib_kernels_api.h b/include/nnlib/xa_nnlib_kernels_api.h
index e0cc344..cf605fc 100644
--- a/include/nnlib/xa_nnlib_kernels_api.h
+++ b/include/nnlib/xa_nnlib_kernels_api.h
@@ -2293,6 +2293,22 @@
             WORD32  inp2_multiplier,
             WORD32  left_shift);

+    WORD32 xa_nn_elm_squared_diff_broadcast_4D_sym16sxsym16s_sym16s(WORD16 * __restrict__ p_out,
+            const WORD32 *const p_out_shape,
+            WORD32  out_left_shift,
+            WORD32  out_multiplier,
+            WORD32  out_activation_min,
+            WORD32  out_activation_max,
+            const WORD16 * __restrict__ p_inp1,
+            const WORD32 *const p_inp1_shape,
+            WORD32  inp1_left_shift,
+            WORD32  inp1_multiplier,
+            const WORD16 * __restrict__ p_inp2,
+            const WORD32 *const p_inp2_shape,
+            WORD32  inp2_left_shift,
+            WORD32  inp2_multiplier,
+            WORD32  left_shift);
+
     WORD32 xa_nn_lstm_cell_state_update_16(WORD16* p_cell_state,
             const WORD16* p_forget_gate,
             const WORD16* p_cell_gate,
